var tipuesearch = {"pages":[{"text":"Fortran Program Hi, my name is ian-admin. This is a project which I wrote. This file will provide the documents. I'm\nwriting the body of the text here. It contains an overall description of the\nproject. It might explain how to go about installing/compiling it. It might\nprovide a change-log for the code. linalg Maybe it will talk about the\nhistory and/or motivation for this software. Note You can include any notes (or bugs, warnings, or todos) like so. Bug You can have multi-paragraph versions of these too! That means you can\ninclude ordered lists unordered lists images etc. Isn't that cool? Bug Hey I'm doing it again... This ones ends mid... ...paragraph. You can have as many paragraphs as you like here and can use headlines, links,\nimages, etc. Basically, you can use anything in Markdown and Markdown-Extra.\nFurthermore, you can insert LaTeX into your documentation. So, for example,\nyou can provide inline math using like y = x&#94;2 or math on its own line\nlike x = \\sqrt{y} or e = mc&#94;2. You can even use LaTeX environments!\nSo you can get numbered equations like this: \\begin{equation}\n  PV = nRT\n\\end{equation} So let your imagination run wild. As you can tell, I'm more or less just\nfilling in space now. This will be the last sentence. Developer Info I. J. Bush I program stuff in Fortran.","tags":"home","loc":"index.html","title":" Fortran Program "},{"text":"This file depends on sourcefile~~grid_vectors.f90~~EfferentGraph sourcefile~grid_vectors.f90 grid_vectors.f90 sourcefile~constants.f90 constants.f90 sourcefile~grid_vectors.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~grid_vectors.f90~~AfferentGraph sourcefile~grid_vectors.f90 grid_vectors.f90 sourcefile~fd_template.f90 fd_template.f90 sourcefile~fd_template.f90->sourcefile~grid_vectors.f90 sourcefile~laplacian_fd.f90 laplacian_fd.f90 sourcefile~laplacian_fd.f90->sourcefile~fd_template.f90 sourcefile~test.f90 test.f90 sourcefile~test.f90->sourcefile~laplacian_fd.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules grid_vectors_module Source Code grid_vectors.f90 Source Code Module grid_vectors_module !!---------------------------------------------------- !! Module containing type and functions pertaining to !! calculating finite-difference grid contributions !! for non-orthonormal grids. !! !! Written by I.J. Bush !!---------------------------------------------------- Use numbers_module , Only : wp Implicit None Type , Public :: grid_vectors !!---------------------------------------------------- !! Type to handle grids of arbitrary size and orientation !! and the calculation of relevant parameters thereof !! !! Written by I.J. Bush !!---------------------------------------------------- Real ( wp ), Dimension ( :, : ), Allocatable , Private :: dir_vecs Real ( wp ), Private :: volume Real ( wp ), Dimension ( :, : ), Allocatable , Private :: inv_vecs Contains Procedure , Public :: set_dir_vecs Procedure , Public :: get_dir_vec Procedure , Public :: get_volume Procedure , Public :: get_inv_vec End type grid_vectors Private Contains Subroutine set_dir_vecs ( g , vecs ) !!---------------------------------------------------- !! Set grid vectors as an NxN array (vecs) and thereby !! calculate the various properties for use with the !! rest of the solvers !! !! Written by I.J. Bush !!---------------------------------------------------- Class ( grid_vectors ) , Intent ( InOut ) :: g Real ( wp ), Dimension ( :, : ), Intent ( In ) :: vecs Real ( wp ) :: V g % dir_vecs = vecs Allocate ( g % inv_vecs , Mold = g % dir_vecs ) Call givens_invert ( g % dir_vecs , g % inv_vecs , V ) g % volume = Abs ( V ) End Subroutine set_dir_vecs Pure Function get_dir_vec ( g , which ) Result ( v ) !!---------------------------------------------------- !! Get the direction of a given (which) vector from !! the direction vecs !! !! Written by I.J. Bush !!---------------------------------------------------- Real ( wp ), Dimension ( : ), Allocatable :: v Class ( grid_vectors ), Intent ( In ) :: g Integer , Intent ( In ) :: which v = g % dir_vecs ( :, which ) End Function get_dir_vec Pure Function get_inv_vec ( g , which ) Result ( v ) !!---------------------------------------------------- !! Get the inverse direction of a given (which) vector from !! the direction vecs !! !! Written by I.J. Bush !!---------------------------------------------------- Real ( wp ), Dimension ( : ), Allocatable :: v Class ( grid_vectors ), Intent ( In ) :: g Integer , Intent ( In ) :: which v = g % inv_vecs ( which , : ) End Function get_inv_vec Pure Function get_volume ( g ) Result ( V ) !!---------------------------------------------------- !! Get the volume element from the vectors !! !! Written by I.J. Bush !!---------------------------------------------------- Real ( wp ) :: V Class ( grid_vectors ), Intent ( In ) :: g V = g % volume End Function get_volume Subroutine givens_invert ( A , B , det ) !!---------------------------------------------------- !! Invert the matrix A, returning the inverse in B !! and the determinant of A in det !! !! NOT FOR USE ON LARGE MATRICES !! !! Really designed as a robust, not totally disastorous, way !! to find inverse lattice vectors and the volume of the unit cell !! ( i.e. the determinant ) !! !! The method used is to QR factorise ( in fact LQ factorise ), !! invert the triangular matrix and the from that form the !! inverse of the original matrix. The determinant is simply the !! product of the diagonal elements of the diagonal matrix. !! Method chosen as easy to implement and nicely numerically stable, !! especially for the small matrices need here. !! !! Written by I.J. Bush !!---------------------------------------------------- Real ( wp ), Dimension ( 1 :, 1 : ), Intent ( In ) :: A Real ( wp ), Dimension ( 1 :, 1 : ), Intent ( Out ) :: B Real ( wp ) , Intent ( Out ), Optional :: det Real ( wp ), Dimension ( :, : ), Allocatable :: Q , L Real ( wp ) :: theta , c , s Real ( wp ) :: ann , anm Real ( wp ) :: Lim , Lin Real ( wp ) :: Qmi , Qni Real ( wp ) :: mv Integer :: dim Integer :: m , n Integer :: i ! Size of the problem dim = Size ( A , dim = 1 ) ! The factors of the matrix A Allocate ( L ( 1 : dim , 1 : dim ) ) Allocate ( Q ( 1 : dim , 1 : dim ) ) ! Factorise A by Givens rotations L = A Q = 0.0_wp Do i = 1 , dim Q ( i , i ) = 1.0_wp End Do LQ_factorise : Do m = 2 , dim Do n = 1 , m - 1 ! For element mn generate the rotation which ! will zweo that element ann = L ( n , n ) anm = L ( n , m ) theta = atan2 ( - anm , ann ) c = Cos ( theta ) s = Sin ( theta ) ! And apply that rotation to the original matrix Do i = 1 , Dim Lim = L ( i , m ) Lin = L ( i , n ) L ( i , n ) = c * Lin - s * Lim L ( i , m ) = c * Lim + s * Lin End Do ! And then apply the rotation to the orthognal matrix Do i = 1 , Dim Qmi = Q ( m , i ) Qni = Q ( n , i ) Q ( n , i ) = c * Qni - s * Qmi Q ( m , i ) = c * Qmi + s * Qni End Do End Do End Do LQ_factorise ! Now invert the triangular matrix, returning the inverse in B B ( 1 , 1 ) = 1.0_wp / L ( 1 , 1 ) B ( 1 , 2 : ) = 0.0_wp Do m = 2 , dim Do n = 1 , m mv = 0.0_wp Do i = 1 , m - 1 mv = mv - L ( m , i ) * B ( i , n ) End Do If ( m == n ) Then mv = mv + 1.0_wp End If mv = mv / L ( m , m ) B ( m , n ) = mv End Do B ( m , n : ) = 0.0_wp End Do ! The inverse of A is now trivially formed B = Matmul ( Transpose ( Q ), B ) ! And generate the determinant If ( Present ( det ) ) Then det = 1.0_wp Do i = 1 , dim det = det * L ( i , i ) End Do End If Deallocate ( Q ) Deallocate ( L ) End Subroutine givens_invert End Module grid_vectors_module","tags":"","loc":"sourcefile/grid_vectors.f90.html","title":"grid_vectors.f90 – Fortran Program"},{"text":"This file depends on sourcefile~~laplacian_fd.f90~~EfferentGraph sourcefile~laplacian_fd.f90 laplacian_fd.f90 sourcefile~fd_template.f90 fd_template.f90 sourcefile~laplacian_fd.f90->sourcefile~fd_template.f90 sourcefile~constants.f90 constants.f90 sourcefile~laplacian_fd.f90->sourcefile~constants.f90 sourcefile~grid_vectors.f90 grid_vectors.f90 sourcefile~fd_template.f90->sourcefile~grid_vectors.f90 sourcefile~grid_vectors.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~laplacian_fd.f90~~AfferentGraph sourcefile~laplacian_fd.f90 laplacian_fd.f90 sourcefile~test.f90 test.f90 sourcefile~test.f90->sourcefile~laplacian_fd.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules FD_Laplacian_3d_module Source Code laplacian_fd.f90 Source Code Module FD_Laplacian_3d_module Use numbers_module , Only : wp Use FD_template_module , Only : FD_template Implicit None Integer , Parameter :: n_cache = ( 2 ** 18 ) / ( 8 ) ! Number of reals in cache Integer , Parameter , Public :: XX = 1 Integer , Parameter , Public :: XY = 2 Integer , Parameter , Public :: XZ = 3 Integer , Parameter , Public :: YY = 4 Integer , Parameter , Public :: YZ = 5 Integer , Parameter , Public :: ZZ = 6 Type , Extends ( FD_template ), Public :: FD_Laplacian_3d Integer , Dimension ( 1 : 3 ), Private :: nc_block Real ( wp ), Dimension ( 1 : 6 ), Private :: deriv_weights Contains Procedure , Public :: init Procedure , Public :: reset_vecs Procedure , Public :: apply End type FD_Laplacian_3d Private Contains Subroutine init ( FD , order , vecs ) !!---------------------------------------------------- !! Initialise Laplacian differentiator and calculate !! optimal blocking in cache. !! !! Written by I.J. Bush !!---------------------------------------------------- Class ( FD_Laplacian_3d ) , Intent ( Out ) :: FD Integer , Intent ( In ) :: order Real ( wp ), Dimension ( :, : ), Intent ( In ) :: vecs Call FD % FD_init ( 2 , order / 2 , vecs ) FD % nc_block = 1 Do While ( usage ( FD % nc_block , 2 * FD % get_order () ) < n_cache ) FD % nc_block = FD % nc_block + 1 End Do FD % nc_block ( 1 ) = FD % nc_block ( 1 ) + 1 If ( usage ( FD % nc_block , 2 * FD % get_order () ) >= n_cache ) Then FD % nc_block ( 1 ) = FD % nc_block ( 1 ) - 1 Else FD % nc_block ( 2 ) = FD % nc_block ( 2 ) + 1 If ( usage ( FD % nc_block , 2 * FD % get_order () ) >= n_cache ) Then FD % nc_block ( 2 ) = FD % nc_block ( 2 ) - 1 End If End If Call FD % reset_vecs ( vecs ) End Subroutine init Subroutine reset_vecs ( FD , vecs ) !!----------------------------------------------------------- !! Calculate weights due to grid offset for non-orthogonal grids !! !! Written by I.J. Bush !!----------------------------------------------------------- Class ( FD_Laplacian_3d ) , Intent ( InOut ) :: FD Real ( wp ), Dimension ( :, : ), Intent ( In ) :: vecs Integer :: this Integer :: i , j this = 0 Do i = 1 , 3 Do j = i , 3 this = this + 1 FD % deriv_weights ( this ) = Dot_Product ( FD % get_inv_vec ( i ), FD % get_inv_vec ( j ) ) If ( i /= j ) FD % deriv_weights ( this ) = 2.0_wp * FD % deriv_weights ( this ) End Do End Do End Subroutine reset_vecs Subroutine apply ( FD , grid_lb , lap_lb , start , final , grid , laplacian ) !!----------------------------------------------------------- !! Calculate the resulting derivative by applying sequentially !! to the precalculated cache-blocks !! !! Written by I.J. Bush !!----------------------------------------------------------- Class ( FD_Laplacian_3d ) , Intent ( In ) :: FD Integer , Dimension ( 3 ) , Intent ( In ) :: grid_lb !! lower bounds grid Integer , Dimension ( 3 ) , Intent ( In ) :: lap_lb !! lower bounds laplacian Integer , Dimension ( 3 ) , Intent ( In ) :: start !! start point for calculation Integer , Dimension ( 3 ) , Intent ( In ) :: final !! final point for calculation Real ( wp ), Dimension ( grid_lb ( 1 ):, grid_lb ( 2 ):, grid_lb ( 3 ): ), Intent ( In ) :: grid !! Thing to be differentiated Real ( wp ), Dimension ( lap_lb ( 1 ):, lap_lb ( 2 ):, lap_lb ( 3 ): ), Intent ( Out ) :: laplacian Real ( wp ), Dimension ( : ), Allocatable :: w1 , w2 Integer :: order Integer :: i_block_3 , i_block_2 , i_block_1 order = FD % get_order () w1 = FD % get_weight ( 1 ) w2 = FD % get_weight ( 2 ) !$omp do collapse( 3 ) Do i_block_3 = start ( 3 ), final ( 3 ), FD % nc_block ( 3 ) Do i_block_2 = start ( 2 ), final ( 2 ), FD % nc_block ( 2 ) Do i_block_1 = start ( 1 ), final ( 1 ), FD % nc_block ( 1 ) Call apply_block ( [ i_block_1 , i_block_2 , i_block_3 ], & grid_lb , lap_lb , FD % nc_block , final , & order , w1 , w2 , FD % deriv_weights , grid , laplacian ) End Do End Do End Do !$omp end do End Subroutine apply Pure Subroutine apply_block ( s , lg , ll , nb , f , order , w1 , w2 , deriv_weights , grid , laplacian ) !!----------------------------------------------------------- !! Apply the FD laplacian operator to part of the grid. An effort has been made !! to make sure the required data is in cache !! !! Written by I.J. Bush !!----------------------------------------------------------- Integer , Dimension ( 1 : 3 ) , Intent ( In ) :: s !! Where to start Integer , Dimension ( 1 : 3 ) , Intent ( In ) :: lg !! Lower bound of grid array Integer , Dimension ( 1 : 3 ) , Intent ( In ) :: ll !! Lower bound of laplacian array Integer , Dimension ( 1 : 3 ) , Intent ( In ) :: nb !! Cache blocking factors Integer , Dimension ( 1 : 3 ) , Intent ( In ) :: f !! Where to finish Integer , Intent ( In ) :: order !! Order of the FD approximation Real ( wp ), Dimension ( - order : ), Intent ( In ) :: w1 !! FD Weights for first derivs Real ( wp ), Dimension ( - order : ), Intent ( In ) :: w2 !! FD Weights for second derivs Real ( wp ), Dimension ( 1 : 6 ), Intent ( In ) :: deriv_weights !! See below Real ( wp ), Dimension ( lg ( 1 ):, lg ( 2 ):, lg ( 3 ): ), Intent ( In ) :: grid !! The source Real ( wp ), Dimension ( ll ( 1 ):, ll ( 2 ):, ll ( 3 ): ), Intent ( InOut ) :: laplacian !! The result ! Deriv_weights: As we do NOT assume the grid is orthogonal our FD laplacian is of the form ! d_xx * del_xx + d_xy * del_xy + d_xz * del_xz + d_yy * del_yy + d_yz * del_yz + d_zz * del_zz ! as we must finite difference along the directions of the grid. deriv_weights are the d_xx, d_xy ! etc. coefficients in this expression Real ( wp ), Parameter :: orthog_tol = 1.0e-14_wp Real ( wp ) :: st1 , st2 , st3 Real ( wp ) :: fac1 , fac2 , fac3 Real ( wp ) :: st12 , st13 , st23 Real ( wp ) :: fac12 , fac13 , fac23 Integer :: i3 , i2 , i1 Integer :: it , it1 , it2 , it3 ! Order the loops for the various terms so that the inner loop is stride 1 ! First do the xx, yy, zz terms. Assume the weights of these are always non-zero Do i3 = s ( 3 ), Min ( s ( 3 ) + nb ( 3 ) - 1 , f ( 3 ) ) Do i2 = s ( 2 ), Min ( s ( 2 ) + nb ( 2 ) - 1 , f ( 2 ) ) Do i1 = s ( 1 ), Min ( s ( 1 ) + nb ( 1 ) - 1 , f ( 1 ) ) ! FD x&#94;2, y&#94;2, z&#94;2 at grid point laplacian ( i1 , i2 , i3 ) = w2 ( 0 ) * deriv_weights ( 1 ) * grid ( i1 , i2 , i3 ) laplacian ( i1 , i2 , i3 ) = laplacian ( i1 , i2 , i3 ) + w2 ( 0 ) * deriv_weights ( 4 ) * grid ( i1 , i2 , i3 ) laplacian ( i1 , i2 , i3 ) = laplacian ( i1 , i2 , i3 ) + w2 ( 0 ) * deriv_weights ( 6 ) * grid ( i1 , i2 , i3 ) ! FD x&#94;2 Do it = 1 , order fac1 = w2 ( it ) * deriv_weights ( 1 ) st1 = ( grid ( i1 + it , i2 , i3 ) + grid ( i1 - it , i2 , i3 ) ) laplacian ( i1 , i2 , i3 ) = laplacian ( i1 , i2 , i3 ) + fac1 * st1 End Do End Do End Do End Do ! FD y&#94;2, z&#94;2 Do i3 = s ( 3 ), Min ( s ( 3 ) + nb ( 3 ) - 1 , f ( 3 ) ) Do i2 = s ( 2 ), Min ( s ( 2 ) + nb ( 2 ) - 1 , f ( 2 ) ) Do it = 1 , order Do i1 = s ( 1 ), Min ( s ( 1 ) + nb ( 1 ) - 1 , f ( 1 ) ) fac2 = w2 ( it ) * deriv_weights ( 4 ) st2 = ( grid ( i1 , i2 + it , i3 ) + grid ( i1 , i2 - it , i3 ) ) laplacian ( i1 , i2 , i3 ) = laplacian ( i1 , i2 , i3 ) + fac2 * st2 fac3 = w2 ( it ) * deriv_weights ( 6 ) st3 = ( grid ( i1 , i2 , i3 + it ) + grid ( i1 , i2 , i3 - it ) ) laplacian ( i1 , i2 , i3 ) = laplacian ( i1 , i2 , i3 ) + fac3 * st3 End Do End Do End Do End Do ! xy If ( Abs ( deriv_weights ( 2 ) ) > orthog_tol ) Then Do i3 = s ( 3 ), Min ( s ( 3 ) + nb ( 3 ) - 1 , f ( 3 ) ) Do i2 = s ( 2 ), Min ( s ( 2 ) + nb ( 2 ) - 1 , f ( 2 ) ) Do it2 = 1 , order Do i1 = s ( 1 ), Min ( s ( 1 ) + nb ( 1 ) - 1 , f ( 1 ) ) ! first derivs have zero weight at the grid point for central differences Do it1 = 1 , order fac12 = w1 ( it1 ) * w1 ( it2 ) * deriv_weights ( 2 ) st12 = grid ( i1 + it1 , i2 + it2 , i3 ) - grid ( i1 - it1 , i2 + it2 , i3 ) - & ( grid ( i1 + it1 , i2 - it2 , i3 ) - grid ( i1 - it1 , i2 - it2 , i3 ) ) laplacian ( i1 , i2 , i3 ) = laplacian ( i1 , i2 , i3 ) + fac12 * st12 End Do End Do End Do End Do End Do End If ! xz If ( Abs ( deriv_weights ( 3 ) ) > orthog_tol ) Then Do i3 = s ( 3 ), Min ( s ( 3 ) + nb ( 3 ) - 1 , f ( 3 ) ) Do it3 = 1 , order Do i2 = s ( 2 ), Min ( s ( 2 ) + nb ( 2 ) - 1 , f ( 2 ) ) Do i1 = s ( 1 ), Min ( s ( 1 ) + nb ( 1 ) - 1 , f ( 1 ) ) ! first derivs have zero weight at the grid point for central differences Do it1 = 1 , order fac13 = w1 ( it1 ) * w1 ( it3 ) * deriv_weights ( 3 ) st13 = grid ( i1 + it1 , i2 , i3 + it3 ) - grid ( i1 - it1 , i2 , i3 + it3 ) - & ( grid ( i1 + it1 , i2 , i3 - it3 ) - grid ( i1 - it1 , i2 , i3 - it3 ) ) laplacian ( i1 , i2 , i3 ) = laplacian ( i1 , i2 , i3 ) + fac13 * st13 End Do End Do End Do End Do End Do End If ! yz If ( Abs ( deriv_weights ( 5 ) ) > orthog_tol ) Then Do i3 = s ( 3 ), Min ( s ( 3 ) + nb ( 3 ) - 1 , f ( 3 ) ) Do it3 = 1 , order Do i2 = s ( 2 ), Min ( s ( 2 ) + nb ( 2 ) - 1 , f ( 2 ) ) ! first derivs have zero weight at the grid point for central differences Do it2 = 1 , order Do i1 = s ( 1 ), Min ( s ( 1 ) + nb ( 1 ) - 1 , f ( 1 ) ) fac23 = w1 ( it2 ) * w1 ( it3 ) * deriv_weights ( 5 ) st23 = grid ( i1 , i2 + it2 , i3 + it3 ) - grid ( i1 , i2 - it2 , i3 + it3 ) - & ( grid ( i1 , i2 + it2 , i3 - it3 ) - grid ( i1 , i2 - it2 , i3 - it3 ) ) laplacian ( i1 , i2 , i3 ) = laplacian ( i1 , i2 , i3 ) + fac23 * st23 End Do End Do End Do End Do End Do End If End Subroutine apply_block Pure Function usage ( nc_block , accuracy ) Result ( reals ) !!----------------------------------------------------------- !! Estimate memory usage of current block size !! !! Written by I.J. Bush !!----------------------------------------------------------- Integer :: reals Integer , Dimension ( 1 : 3 ), Intent ( In ) :: nc_block Integer , Intent ( In ) :: accuracy Integer :: grid Integer :: fd grid = Product ( nc_block ) fd = Product ( nc_block + 1 + accuracy ) reals = grid + fd End Function usage End Module FD_Laplacian_3d_module","tags":"","loc":"sourcefile/laplacian_fd.f90.html","title":"laplacian_fd.f90 – Fortran Program"},{"text":"Files dependent on this one sourcefile~~constants.f90~~AfferentGraph sourcefile~constants.f90 constants.f90 sourcefile~grid_vectors.f90 grid_vectors.f90 sourcefile~grid_vectors.f90->sourcefile~constants.f90 sourcefile~laplacian_fd.f90 laplacian_fd.f90 sourcefile~laplacian_fd.f90->sourcefile~constants.f90 sourcefile~fd_template.f90 fd_template.f90 sourcefile~laplacian_fd.f90->sourcefile~fd_template.f90 sourcefile~test.f90 test.f90 sourcefile~test.f90->sourcefile~constants.f90 sourcefile~test.f90->sourcefile~laplacian_fd.f90 sourcefile~fd_template.f90->sourcefile~grid_vectors.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules numbers_module Source Code constants.f90 Source Code Module numbers_module Implicit None Integer , Parameter , Public :: wp = Selected_real_kind ( 12 , 70 ) Private End Module numbers_module","tags":"","loc":"sourcefile/constants.f90.html","title":"constants.f90 – Fortran Program"},{"text":"This file depends on sourcefile~~fd_template.f90~~EfferentGraph sourcefile~fd_template.f90 fd_template.f90 sourcefile~grid_vectors.f90 grid_vectors.f90 sourcefile~fd_template.f90->sourcefile~grid_vectors.f90 sourcefile~constants.f90 constants.f90 sourcefile~grid_vectors.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~fd_template.f90~~AfferentGraph sourcefile~fd_template.f90 fd_template.f90 sourcefile~laplacian_fd.f90 laplacian_fd.f90 sourcefile~laplacian_fd.f90->sourcefile~fd_template.f90 sourcefile~test.f90 test.f90 sourcefile~test.f90->sourcefile~laplacian_fd.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules FD_template_module Source Code fd_template.f90 Source Code Module FD_template_module !!----------------------------------------------------------- !! Module containing type to construct finite difference weights !! for arbitrary order derivatives, stencils and arbitrary grids !! !! Written by I.J. Bush !!----------------------------------------------------------- Use grid_vectors_module , Only : grid_vectors Implicit None Integer , Parameter , Public :: wp = Selected_real_kind ( 15 , 300 ) Private Type , Abstract , Extends ( grid_vectors ), Public :: FD_template !!----------------------------------------------------------- !! Low-level type for handling weights for arbitray stencils !! and derivatives, contains grid_vector information through !! the extension of the grid_vectors type. !! !! Do not use this type directly. !! !! Written by I.J. Bush !!----------------------------------------------------------- Integer , Private :: max_deriv Integer , Private :: order Real ( wp ), Dimension ( :, : ), Allocatable , Private :: weights Contains Procedure , Public :: FD_init Procedure , Public :: set_order Procedure , Public :: get_order Procedure , Public :: get_max_deriv Procedure , Public :: get_weight End type FD_template Contains Subroutine FD_init ( FD , max_deriv , order , vecs ) !!----------------------------------------------------------- !! Initialise finite difference object for arbitrary grids !! !! Written by I.J. Bush !!----------------------------------------------------------- Class ( FD_template ) , Intent ( Out ) :: FD Integer , Intent ( In ) :: max_deriv Integer , Intent ( In ) :: order Real ( wp ), Dimension ( :, : ), Intent ( In ) :: vecs Call FD % set_order ( max_deriv , order ) Call FD % set_dir_vecs ( vecs ) End Subroutine FD_init Subroutine set_order ( FD , max_deriv , order ) !!----------------------------------------------------------- !! Set derivative and stencil and calculate respective weights !! !! Written by I.J. Bush !!----------------------------------------------------------- Class ( FD_template ), Intent ( InOut ) :: FD Integer , Intent ( In ) :: max_deriv Integer , Intent ( In ) :: order Integer :: i FD % max_deriv = max_deriv FD % order = order Call weights ( 0.0_wp , [ ( Real ( i , wp ), i = - FD % order , FD % order ) ], & FD % max_deriv , FD % weights ) End Subroutine set_order Pure Function get_order ( FD ) Result ( order ) !!----------------------------------------------------------- !! Return stencil order !! !! Written by I.J. Bush !!----------------------------------------------------------- Integer :: order Class ( FD_template ), Intent ( In ) :: FD order = FD % order End Function get_order Pure Function get_max_deriv ( FD ) Result ( max_deriv ) !!----------------------------------------------------------- !! Return maximum possible derivative order !! !! Written by I.J. Bush !!----------------------------------------------------------- Integer :: max_deriv Class ( FD_template ), Intent ( In ) :: FD max_deriv = FD % max_deriv End Function get_max_deriv Pure Function get_weight ( FD , deriv ) Result ( weight ) !!----------------------------------------------------------- !! Return FD weights for given derivative order !! !! Written by I.J. Bush !!----------------------------------------------------------- Real ( wp ), Allocatable , Dimension ( : ) :: weight Class ( FD_template ), Intent ( In ) :: FD Integer , Intent ( In ) :: deriv Allocate ( weight ( - FD % order : FD % order ) ) weight = FD % weights ( :, deriv ) End Function get_weight Subroutine weights ( centre , sample_points , deriv , coeffs ) !!----------------------------------------------------------- !! Input Arguments !! centre                      -- location where approximations are to be accurate, !! sample_points(0:n_samples)  -- grid point locations !! deriv                       -- highest derivative for which weights are sought, !! !! Output Arguments !! coeffs(0:n_samples,0:deriv) -- weights at sample_points for derivatives order deriv !! !! Taken from https://pdfs.semanticscholar.org/8bf5/912bde884f6bd4cfb4991ba3d077cace94c0.pdf !! By Bengt Fornberg !!----------------------------------------------------------- Implicit None Real ( wp ), Intent ( In ) :: centre Real ( wp ), Dimension ( 0 : ), Intent ( In ) :: sample_points Integer , Intent ( In ) :: deriv Real ( wp ), Dimension ( :, : ), Allocatable , Intent ( Out ) :: coeffs Integer :: n Real ( wp ) :: c1 , c2 , c3 , c4 , c5 Integer :: mn Integer :: i , j , k Integer :: ierr n = size ( sample_points ) - 1 Allocate ( coeffs ( 0 : n , 0 : deriv ), stat = ierr ) If ( ierr /= 0 ) Stop \"Error in allocation of coeffs in weights\" c1 = 1.0_wp c4 = sample_points ( 0 ) - centre coeffs = 0.0_wp coeffs ( 0 , 0 ) = 1.0_wp Do i = 1 , n mn = Min ( i , deriv ) c2 = 1.0_wp c5 = c4 c4 = sample_points ( i ) - centre Do j = 0 , i - 1 c3 = sample_points ( i ) - sample_points ( j ) c2 = c2 * c3 If ( j . Eq . i - 1 ) Then ! If final iteration Do k = mn , 1 , - 1 coeffs ( i , k ) = c1 * ( k * coeffs ( i - 1 , k - 1 ) - c5 * coeffs ( i - 1 , k )) / c2 End Do coeffs ( i , 0 ) = - c1 * c5 * coeffs ( i - 1 , 0 ) / c2 Endif Do k = mn , 1 , - 1 coeffs ( j , k ) = ( c4 * coeffs ( j , k ) - k * coeffs ( j , k - 1 )) / c3 End Do coeffs ( j , 0 ) = c4 * coeffs ( j , 0 ) / c3 End Do c1 = c2 End Do End Subroutine weights End Module FD_template_module","tags":"","loc":"sourcefile/fd_template.f90.html","title":"fd_template.f90 – Fortran Program"},{"text":"This file depends on sourcefile~~test.f90~~EfferentGraph sourcefile~test.f90 test.f90 sourcefile~laplacian_fd.f90 laplacian_fd.f90 sourcefile~test.f90->sourcefile~laplacian_fd.f90 sourcefile~constants.f90 constants.f90 sourcefile~test.f90->sourcefile~constants.f90 sourcefile~laplacian_fd.f90->sourcefile~constants.f90 sourcefile~fd_template.f90 fd_template.f90 sourcefile~laplacian_fd.f90->sourcefile~fd_template.f90 sourcefile~grid_vectors.f90 grid_vectors.f90 sourcefile~fd_template.f90->sourcefile~grid_vectors.f90 sourcefile~grid_vectors.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs testit Source Code test.f90 Source Code Program testit !!---------------------------------------------------- !! Program to test the execution of the finite difference !! library by calculating the charge from a screened !! Gaussian according to !!  \\rho _i&#94;s(\\mathbf r)=-q_i\\left(\\frac{\\alpha }{\\sqrt{\\pi }}\\right)&#94;3e&#94;{-\\alpha&#94;2 |\\mathbf r-\\mathbf r_i|&#94;2}  !! !! Written by I.J. Bush !!---------------------------------------------------- Use numbers_module , Only : wp Use FD_Laplacian_3d_module , Only : FD_Laplacian_3D Implicit None Type ( FD_Laplacian_3d ) :: FD Real ( wp ), Dimension ( :, :, : ), Allocatable :: grid Real ( wp ), Dimension ( :, :, : ), Allocatable :: laplacian Real ( wp ), Dimension ( :, :, : ), Allocatable :: fd_laplacian Real ( wp ), Dimension ( 1 : 3 , 1 : 3 ) :: grid_vecs Real ( wp ), Dimension ( 1 : 3 ) :: r , ri Real ( wp ) :: alpha , alpha_sq Real ( wp ) :: x , y , z Real ( wp ) :: norm Real ( wp ) :: arg Real ( wp ) :: gauss , gauss_x2 , gauss_y2 , gauss_z2 Integer , Dimension ( 1 : 3 ) :: grid_size , grid_with_halo Integer :: order Integer :: i3 , i2 , i1 Write ( * , * ) 'Grid vecs?' Read ( * , * ) grid_vecs Write ( * , * ) 'ri ?' Read ( * , * ) ri Write ( * , * ) 'alpha ?' Read ( * , * ) alpha alpha_sq = alpha * alpha Write ( * , * ) 'order ?' Read ( * , * ) order Write ( * , * ) 'grid_size ?' Read ( * , * ) grid_size grid_with_halo = grid_size + order / 2 Allocate ( grid ( & & - grid_with_halo ( 1 ): grid_with_halo ( 1 ), & & - grid_with_halo ( 2 ): grid_with_halo ( 2 ), & & - grid_with_halo ( 3 ): grid_with_halo ( 3 ) ) ) Allocate ( laplacian ( & & - grid_with_halo ( 1 ): grid_with_halo ( 1 ), & & - grid_with_halo ( 2 ): grid_with_halo ( 2 ), & & - grid_with_halo ( 3 ): grid_with_halo ( 3 ) ) ) Allocate ( fd_laplacian ( & & - grid_size ( 1 ): grid_size ( 1 ), & & - grid_size ( 2 ): grid_size ( 2 ), & & - grid_size ( 3 ): grid_size ( 3 ) ) ) norm = ( alpha / Sqrt ( 3.1415926535897932384626433832795_wp ) ) ** 3 Do i3 = - grid_with_halo ( 3 ), grid_with_halo ( 3 ) Do i2 = - grid_with_halo ( 2 ), grid_with_halo ( 2 ) Do i1 = - grid_with_halo ( 1 ), grid_with_halo ( 1 ) r = i1 * grid_vecs ( :, 1 ) + i2 * grid_vecs ( :, 2 ) + i3 * grid_vecs ( :, 3 ) - ri arg = alpha_sq * Dot_Product ( r , r ) gauss = norm * Exp ( - arg ) grid ( i1 , i2 , i3 ) = gauss x = r ( 1 ) y = r ( 2 ) z = r ( 3 ) gauss_x2 = gauss * ( - 2.0_wp * alpha_sq + 4.0 * alpha_sq * alpha_sq * x * x ) gauss_y2 = gauss * ( - 2.0_wp * alpha_sq + 4.0 * alpha_sq * alpha_sq * y * y ) gauss_z2 = gauss * ( - 2.0_wp * alpha_sq + 4.0 * alpha_sq * alpha_sq * z * z ) laplacian ( i1 , i2 , i3 ) = gauss_x2 + gauss_y2 + gauss_z2 End Do End Do End Do Call FD % init ( order , grid_vecs ) Call FD % apply ( - grid_with_halo , - grid_size , & - grid_size , grid_size , & grid , fd_laplacian ) Write ( * , * ) Maxval ( Abs ( fd_laplacian - & laplacian ( & & - grid_size ( 1 ): grid_size ( 1 ), & & - grid_size ( 2 ): grid_size ( 2 ), & & - grid_size ( 3 ): grid_size ( 3 ) ) ) ) Write ( * , * ) Maxval ( Abs ( laplacian ( & & - grid_size ( 1 ): grid_size ( 1 ), & & - grid_size ( 2 ): grid_size ( 2 ), & & - grid_size ( 3 ): grid_size ( 3 ) ) ) ) End Program testit","tags":"","loc":"sourcefile/test.f90.html","title":"test.f90 – Fortran Program"},{"text":"type, public :: grid_vectors Type to handle grids of arbitrary size and orientation\n and the calculation of relevant parameters thereof Written by I.J. Bush Contents Variables dir_vecs volume inv_vecs Type-Bound Procedures set_dir_vecs get_dir_vec get_volume get_inv_vec Source Code grid_vectors Components Type Visibility Attributes Name Initial real(kind=wp), private, Dimension( :, : ), Allocatable :: dir_vecs real(kind=wp), private :: volume real(kind=wp), private, Dimension( :, : ), Allocatable :: inv_vecs Type-Bound Procedures procedure, public :: set_dir_vecs private subroutine set_dir_vecs (g, vecs) Set grid vectors as an NxN array (vecs) and thereby\n calculate the various properties for use with the\n rest of the solvers Read more… Arguments Type Intent Optional Attributes Name class( grid_vectors ), intent(inout) :: g real(kind=wp), intent(in), Dimension( :, : ) :: vecs procedure, public :: get_dir_vec private pure function get_dir_vec (g, which) result(v) Get the direction of a given (which) vector from\n the direction vecs Read more… Arguments Type Intent Optional Attributes Name class( grid_vectors ), intent(in) :: g integer, intent(in) :: which Return Value real(kind=wp),\n  Dimension( : ), Allocatable procedure, public :: get_volume private pure function get_volume (g) result(V) Get the volume element from the vectors Read more… Arguments Type Intent Optional Attributes Name class( grid_vectors ), intent(in) :: g Return Value real(kind=wp) procedure, public :: get_inv_vec private pure function get_inv_vec (g, which) result(v) Get the inverse direction of a given (which) vector from\n the direction vecs Read more… Arguments Type Intent Optional Attributes Name class( grid_vectors ), intent(in) :: g integer, intent(in) :: which Return Value real(kind=wp),\n  Dimension( : ), Allocatable Source Code Type , Public :: grid_vectors !!---------------------------------------------------- !! Type to handle grids of arbitrary size and orientation !! and the calculation of relevant parameters thereof !! !! Written by I.J. Bush !!---------------------------------------------------- Real ( wp ), Dimension ( :, : ), Allocatable , Private :: dir_vecs Real ( wp ), Private :: volume Real ( wp ), Dimension ( :, : ), Allocatable , Private :: inv_vecs Contains Procedure , Public :: set_dir_vecs Procedure , Public :: get_dir_vec Procedure , Public :: get_volume Procedure , Public :: get_inv_vec End type grid_vectors","tags":"","loc":"type/grid_vectors.html","title":"grid_vectors – Fortran Program "},{"text":"type, public, Extends( FD_template ) :: FD_Laplacian_3d Contents Variables nc_block deriv_weights Type-Bound Procedures init reset_vecs apply Source Code FD_Laplacian_3d Components Type Visibility Attributes Name Initial integer, private, Dimension( 1:3 ) :: nc_block real(kind=wp), private, Dimension( 1:6 ) :: deriv_weights Type-Bound Procedures procedure, public :: init private subroutine init (FD, order, vecs) Initialise Laplacian differentiator and calculate\n optimal blocking in cache. Read more… Arguments Type Intent Optional Attributes Name class( FD_Laplacian_3d ), intent(out) :: FD integer, intent(in) :: order real(kind=wp), intent(in), Dimension( :, : ) :: vecs procedure, public :: reset_vecs private subroutine reset_vecs (FD, vecs) Calculate weights due to grid offset for non-orthogonal grids Read more… Arguments Type Intent Optional Attributes Name class( FD_Laplacian_3d ), intent(inout) :: FD real(kind=wp), intent(in), Dimension( :, : ) :: vecs procedure, public :: apply private subroutine apply (FD, grid_lb, lap_lb, start, final, grid, laplacian) Calculate the resulting derivative by applying sequentially\n to the precalculated cache-blocks Read more… Arguments Type Intent Optional Attributes Name class( FD_Laplacian_3d ), intent(in) :: FD integer, intent(in), Dimension(3) :: grid_lb lower bounds grid integer, intent(in), Dimension(3) :: lap_lb lower bounds laplacian integer, intent(in), Dimension(3) :: start start point for calculation integer, intent(in), Dimension(3) :: final final point for calculation real(kind=wp), intent(in), Dimension( grid_lb(1):, grid_lb(2):, grid_lb(3): ) :: grid Thing to be differentiated real(kind=wp), intent(out), Dimension( lap_lb(1):, lap_lb(2):, lap_lb(3): ) :: laplacian Source Code Type , Extends ( FD_template ), Public :: FD_Laplacian_3d Integer , Dimension ( 1 : 3 ), Private :: nc_block Real ( wp ), Dimension ( 1 : 6 ), Private :: deriv_weights Contains Procedure , Public :: init Procedure , Public :: reset_vecs Procedure , Public :: apply End type FD_Laplacian_3d","tags":"","loc":"type/fd_laplacian_3d.html","title":"FD_Laplacian_3d – Fortran Program "},{"text":"type, public, Abstract, Extends( grid_vectors ) :: FD_template Low-level type for handling weights for arbitray stencils\n and derivatives, contains grid_vector information through\n the extension of the grid_vectors type. Do not use this type directly. Written by I.J. Bush Contents Variables max_deriv order weights Type-Bound Procedures FD_init set_order get_order get_max_deriv get_weight Source Code FD_template Components Type Visibility Attributes Name Initial integer, private :: max_deriv integer, private :: order real(kind=wp), private, Dimension( :, : ), Allocatable :: weights Type-Bound Procedures procedure, public :: FD_init private subroutine FD_init (FD, max_deriv, order, vecs) Initialise finite difference object for arbitrary grids Read more… Arguments Type Intent Optional Attributes Name class( FD_template ), intent(out) :: FD integer, intent(in) :: max_deriv integer, intent(in) :: order real(kind=wp), intent(in), Dimension( :, : ) :: vecs procedure, public :: set_order private subroutine set_order (FD, max_deriv, order) Set derivative and stencil and calculate respective weights Read more… Arguments Type Intent Optional Attributes Name class( FD_template ), intent(inout) :: FD integer, intent(in) :: max_deriv integer, intent(in) :: order procedure, public :: get_order private pure function get_order (FD) result(order) Return stencil order Read more… Arguments Type Intent Optional Attributes Name class( FD_template ), intent(in) :: FD Return Value integer procedure, public :: get_max_deriv private pure function get_max_deriv (FD) result(max_deriv) Return maximum possible derivative order Read more… Arguments Type Intent Optional Attributes Name class( FD_template ), intent(in) :: FD Return Value integer procedure, public :: get_weight private pure function get_weight (FD, deriv) result(weight) Return FD weights for given derivative order Read more… Arguments Type Intent Optional Attributes Name class( FD_template ), intent(in) :: FD integer, intent(in) :: deriv Return Value real(kind=wp),\n  Allocatable, Dimension( : ) Source Code Type , Abstract , Extends ( grid_vectors ), Public :: FD_template !!----------------------------------------------------------- !! Low-level type for handling weights for arbitray stencils !! and derivatives, contains grid_vector information through !! the extension of the grid_vectors type. !! !! Do not use this type directly. !! !! Written by I.J. Bush !!----------------------------------------------------------- Integer , Private :: max_deriv Integer , Private :: order Real ( wp ), Dimension ( :, : ), Allocatable , Private :: weights Contains Procedure , Public :: FD_init Procedure , Public :: set_order Procedure , Public :: get_order Procedure , Public :: get_max_deriv Procedure , Public :: get_weight End type FD_template","tags":"","loc":"type/fd_template.html","title":"FD_template – Fortran Program "},{"text":"private pure function get_dir_vec(g, which) result(v) Get the direction of a given (which) vector from\n the direction vecs Written by I.J. Bush Arguments Type Intent Optional Attributes Name class( grid_vectors ), intent(in) :: g integer, intent(in) :: which Return Value real(kind=wp),\n  Dimension( : ),Allocatable Contents Source Code get_dir_vec Source Code Pure Function get_dir_vec ( g , which ) Result ( v ) !!---------------------------------------------------- !! Get the direction of a given (which) vector from !! the direction vecs !! !! Written by I.J. Bush !!---------------------------------------------------- Real ( wp ), Dimension ( : ), Allocatable :: v Class ( grid_vectors ), Intent ( In ) :: g Integer , Intent ( In ) :: which v = g % dir_vecs ( :, which ) End Function get_dir_vec","tags":"","loc":"proc/get_dir_vec.html","title":"get_dir_vec – Fortran Program"},{"text":"private pure function get_inv_vec(g, which) result(v) Get the inverse direction of a given (which) vector from\n the direction vecs Written by I.J. Bush Arguments Type Intent Optional Attributes Name class( grid_vectors ), intent(in) :: g integer, intent(in) :: which Return Value real(kind=wp),\n  Dimension( : ),Allocatable Contents Source Code get_inv_vec Source Code Pure Function get_inv_vec ( g , which ) Result ( v ) !!---------------------------------------------------- !! Get the inverse direction of a given (which) vector from !! the direction vecs !! !! Written by I.J. Bush !!---------------------------------------------------- Real ( wp ), Dimension ( : ), Allocatable :: v Class ( grid_vectors ), Intent ( In ) :: g Integer , Intent ( In ) :: which v = g % inv_vecs ( which , : ) End Function get_inv_vec","tags":"","loc":"proc/get_inv_vec.html","title":"get_inv_vec – Fortran Program"},{"text":"private pure function get_volume(g) result(V) Get the volume element from the vectors Written by I.J. Bush Arguments Type Intent Optional Attributes Name class( grid_vectors ), intent(in) :: g Return Value real(kind=wp) Contents Source Code get_volume Source Code Pure Function get_volume ( g ) Result ( V ) !!---------------------------------------------------- !! Get the volume element from the vectors !! !! Written by I.J. Bush !!---------------------------------------------------- Real ( wp ) :: V Class ( grid_vectors ), Intent ( In ) :: g V = g % volume End Function get_volume","tags":"","loc":"proc/get_volume.html","title":"get_volume – Fortran Program"},{"text":"private subroutine set_dir_vecs(g, vecs) Set grid vectors as an NxN array (vecs) and thereby\n calculate the various properties for use with the\n rest of the solvers Written by I.J. Bush Arguments Type Intent Optional Attributes Name class( grid_vectors ), intent(inout) :: g real(kind=wp), intent(in), Dimension( :, : ) :: vecs Calls proc~~set_dir_vecs~~CallsGraph proc~set_dir_vecs set_dir_vecs proc~givens_invert givens_invert proc~set_dir_vecs->proc~givens_invert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code set_dir_vecs Source Code Subroutine set_dir_vecs ( g , vecs ) !!---------------------------------------------------- !! Set grid vectors as an NxN array (vecs) and thereby !! calculate the various properties for use with the !! rest of the solvers !! !! Written by I.J. Bush !!---------------------------------------------------- Class ( grid_vectors ) , Intent ( InOut ) :: g Real ( wp ), Dimension ( :, : ), Intent ( In ) :: vecs Real ( wp ) :: V g % dir_vecs = vecs Allocate ( g % inv_vecs , Mold = g % dir_vecs ) Call givens_invert ( g % dir_vecs , g % inv_vecs , V ) g % volume = Abs ( V ) End Subroutine set_dir_vecs","tags":"","loc":"proc/set_dir_vecs.html","title":"set_dir_vecs – Fortran Program"},{"text":"private subroutine givens_invert(A, B, det) Invert the matrix A, returning the inverse in B\n and the determinant of A in det NOT FOR USE ON LARGE MATRICES Really designed as a robust, not totally disastorous, way\n to find inverse lattice vectors and the volume of the unit cell\n ( i.e. the determinant ) The method used is to QR factorise ( in fact LQ factorise ),\n invert the triangular matrix and the from that form the\n inverse of the original matrix. The determinant is simply the\n product of the diagonal elements of the diagonal matrix.\n Method chosen as easy to implement and nicely numerically stable,\n especially for the small matrices need here. Written by I.J. Bush Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), Dimension( 1:, 1: ) :: A real(kind=wp), intent(out), Dimension( 1:, 1: ) :: B real(kind=wp), intent(out), optional :: det Called by proc~~givens_invert~~CalledByGraph proc~givens_invert givens_invert proc~set_dir_vecs set_dir_vecs proc~set_dir_vecs->proc~givens_invert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code givens_invert Source Code Subroutine givens_invert ( A , B , det ) !!---------------------------------------------------- !! Invert the matrix A, returning the inverse in B !! and the determinant of A in det !! !! NOT FOR USE ON LARGE MATRICES !! !! Really designed as a robust, not totally disastorous, way !! to find inverse lattice vectors and the volume of the unit cell !! ( i.e. the determinant ) !! !! The method used is to QR factorise ( in fact LQ factorise ), !! invert the triangular matrix and the from that form the !! inverse of the original matrix. The determinant is simply the !! product of the diagonal elements of the diagonal matrix. !! Method chosen as easy to implement and nicely numerically stable, !! especially for the small matrices need here. !! !! Written by I.J. Bush !!---------------------------------------------------- Real ( wp ), Dimension ( 1 :, 1 : ), Intent ( In ) :: A Real ( wp ), Dimension ( 1 :, 1 : ), Intent ( Out ) :: B Real ( wp ) , Intent ( Out ), Optional :: det Real ( wp ), Dimension ( :, : ), Allocatable :: Q , L Real ( wp ) :: theta , c , s Real ( wp ) :: ann , anm Real ( wp ) :: Lim , Lin Real ( wp ) :: Qmi , Qni Real ( wp ) :: mv Integer :: dim Integer :: m , n Integer :: i ! Size of the problem dim = Size ( A , dim = 1 ) ! The factors of the matrix A Allocate ( L ( 1 : dim , 1 : dim ) ) Allocate ( Q ( 1 : dim , 1 : dim ) ) ! Factorise A by Givens rotations L = A Q = 0.0_wp Do i = 1 , dim Q ( i , i ) = 1.0_wp End Do LQ_factorise : Do m = 2 , dim Do n = 1 , m - 1 ! For element mn generate the rotation which ! will zweo that element ann = L ( n , n ) anm = L ( n , m ) theta = atan2 ( - anm , ann ) c = Cos ( theta ) s = Sin ( theta ) ! And apply that rotation to the original matrix Do i = 1 , Dim Lim = L ( i , m ) Lin = L ( i , n ) L ( i , n ) = c * Lin - s * Lim L ( i , m ) = c * Lim + s * Lin End Do ! And then apply the rotation to the orthognal matrix Do i = 1 , Dim Qmi = Q ( m , i ) Qni = Q ( n , i ) Q ( n , i ) = c * Qni - s * Qmi Q ( m , i ) = c * Qmi + s * Qni End Do End Do End Do LQ_factorise ! Now invert the triangular matrix, returning the inverse in B B ( 1 , 1 ) = 1.0_wp / L ( 1 , 1 ) B ( 1 , 2 : ) = 0.0_wp Do m = 2 , dim Do n = 1 , m mv = 0.0_wp Do i = 1 , m - 1 mv = mv - L ( m , i ) * B ( i , n ) End Do If ( m == n ) Then mv = mv + 1.0_wp End If mv = mv / L ( m , m ) B ( m , n ) = mv End Do B ( m , n : ) = 0.0_wp End Do ! The inverse of A is now trivially formed B = Matmul ( Transpose ( Q ), B ) ! And generate the determinant If ( Present ( det ) ) Then det = 1.0_wp Do i = 1 , dim det = det * L ( i , i ) End Do End If Deallocate ( Q ) Deallocate ( L ) End Subroutine givens_invert","tags":"","loc":"proc/givens_invert.html","title":"givens_invert – Fortran Program"},{"text":"private pure function usage(nc_block, accuracy) result(reals) Estimate memory usage of current block size Written by I.J. Bush Arguments Type Intent Optional Attributes Name integer, intent(in), Dimension( 1:3 ) :: nc_block integer, intent(in) :: accuracy Return Value integer Called by proc~~usage~~CalledByGraph proc~usage usage proc~init init proc~init->proc~usage Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code usage Source Code Pure Function usage ( nc_block , accuracy ) Result ( reals ) !!----------------------------------------------------------- !! Estimate memory usage of current block size !! !! Written by I.J. Bush !!----------------------------------------------------------- Integer :: reals Integer , Dimension ( 1 : 3 ), Intent ( In ) :: nc_block Integer , Intent ( In ) :: accuracy Integer :: grid Integer :: fd grid = Product ( nc_block ) fd = Product ( nc_block + 1 + accuracy ) reals = grid + fd End Function usage","tags":"","loc":"proc/usage.html","title":"usage – Fortran Program"},{"text":"private subroutine init(FD, order, vecs) Initialise Laplacian differentiator and calculate\n optimal blocking in cache. Written by I.J. Bush Arguments Type Intent Optional Attributes Name class( FD_Laplacian_3d ), intent(out) :: FD integer, intent(in) :: order real(kind=wp), intent(in), Dimension( :, : ) :: vecs Calls proc~~init~~CallsGraph proc~init init proc~usage usage proc~init->proc~usage Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code init Source Code Subroutine init ( FD , order , vecs ) !!---------------------------------------------------- !! Initialise Laplacian differentiator and calculate !! optimal blocking in cache. !! !! Written by I.J. Bush !!---------------------------------------------------- Class ( FD_Laplacian_3d ) , Intent ( Out ) :: FD Integer , Intent ( In ) :: order Real ( wp ), Dimension ( :, : ), Intent ( In ) :: vecs Call FD % FD_init ( 2 , order / 2 , vecs ) FD % nc_block = 1 Do While ( usage ( FD % nc_block , 2 * FD % get_order () ) < n_cache ) FD % nc_block = FD % nc_block + 1 End Do FD % nc_block ( 1 ) = FD % nc_block ( 1 ) + 1 If ( usage ( FD % nc_block , 2 * FD % get_order () ) >= n_cache ) Then FD % nc_block ( 1 ) = FD % nc_block ( 1 ) - 1 Else FD % nc_block ( 2 ) = FD % nc_block ( 2 ) + 1 If ( usage ( FD % nc_block , 2 * FD % get_order () ) >= n_cache ) Then FD % nc_block ( 2 ) = FD % nc_block ( 2 ) - 1 End If End If Call FD % reset_vecs ( vecs ) End Subroutine init","tags":"","loc":"proc/init.html","title":"init – Fortran Program"},{"text":"private subroutine reset_vecs(FD, vecs) Calculate weights due to grid offset for non-orthogonal grids Written by I.J. Bush Arguments Type Intent Optional Attributes Name class( FD_Laplacian_3d ), intent(inout) :: FD real(kind=wp), intent(in), Dimension( :, : ) :: vecs Contents Source Code reset_vecs Source Code Subroutine reset_vecs ( FD , vecs ) !!----------------------------------------------------------- !! Calculate weights due to grid offset for non-orthogonal grids !! !! Written by I.J. Bush !!----------------------------------------------------------- Class ( FD_Laplacian_3d ) , Intent ( InOut ) :: FD Real ( wp ), Dimension ( :, : ), Intent ( In ) :: vecs Integer :: this Integer :: i , j this = 0 Do i = 1 , 3 Do j = i , 3 this = this + 1 FD % deriv_weights ( this ) = Dot_Product ( FD % get_inv_vec ( i ), FD % get_inv_vec ( j ) ) If ( i /= j ) FD % deriv_weights ( this ) = 2.0_wp * FD % deriv_weights ( this ) End Do End Do End Subroutine reset_vecs","tags":"","loc":"proc/reset_vecs.html","title":"reset_vecs – Fortran Program"},{"text":"private subroutine apply(FD, grid_lb, lap_lb, start, final, grid, laplacian) Calculate the resulting derivative by applying sequentially\n to the precalculated cache-blocks Written by I.J. Bush Arguments Type Intent Optional Attributes Name class( FD_Laplacian_3d ), intent(in) :: FD integer, intent(in), Dimension(3) :: grid_lb lower bounds grid integer, intent(in), Dimension(3) :: lap_lb lower bounds laplacian integer, intent(in), Dimension(3) :: start start point for calculation integer, intent(in), Dimension(3) :: final final point for calculation real(kind=wp), intent(in), Dimension( grid_lb(1):, grid_lb(2):, grid_lb(3): ) :: grid Thing to be differentiated real(kind=wp), intent(out), Dimension( lap_lb(1):, lap_lb(2):, lap_lb(3): ) :: laplacian Calls proc~~apply~~CallsGraph proc~apply apply proc~apply_block apply_block proc~apply->proc~apply_block Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code apply Source Code Subroutine apply ( FD , grid_lb , lap_lb , start , final , grid , laplacian ) !!----------------------------------------------------------- !! Calculate the resulting derivative by applying sequentially !! to the precalculated cache-blocks !! !! Written by I.J. Bush !!----------------------------------------------------------- Class ( FD_Laplacian_3d ) , Intent ( In ) :: FD Integer , Dimension ( 3 ) , Intent ( In ) :: grid_lb !! lower bounds grid Integer , Dimension ( 3 ) , Intent ( In ) :: lap_lb !! lower bounds laplacian Integer , Dimension ( 3 ) , Intent ( In ) :: start !! start point for calculation Integer , Dimension ( 3 ) , Intent ( In ) :: final !! final point for calculation Real ( wp ), Dimension ( grid_lb ( 1 ):, grid_lb ( 2 ):, grid_lb ( 3 ): ), Intent ( In ) :: grid !! Thing to be differentiated Real ( wp ), Dimension ( lap_lb ( 1 ):, lap_lb ( 2 ):, lap_lb ( 3 ): ), Intent ( Out ) :: laplacian Real ( wp ), Dimension ( : ), Allocatable :: w1 , w2 Integer :: order Integer :: i_block_3 , i_block_2 , i_block_1 order = FD % get_order () w1 = FD % get_weight ( 1 ) w2 = FD % get_weight ( 2 ) !$omp do collapse( 3 ) Do i_block_3 = start ( 3 ), final ( 3 ), FD % nc_block ( 3 ) Do i_block_2 = start ( 2 ), final ( 2 ), FD % nc_block ( 2 ) Do i_block_1 = start ( 1 ), final ( 1 ), FD % nc_block ( 1 ) Call apply_block ( [ i_block_1 , i_block_2 , i_block_3 ], & grid_lb , lap_lb , FD % nc_block , final , & order , w1 , w2 , FD % deriv_weights , grid , laplacian ) End Do End Do End Do !$omp end do End Subroutine apply","tags":"","loc":"proc/apply.html","title":"apply – Fortran Program"},{"text":"private subroutine apply_block(s, lg, ll, nb, f, order, w1, w2, deriv_weights, grid, laplacian) Apply the FD laplacian operator to part of the grid. An effort has been made\n to make sure the required data is in cache Written by I.J. Bush Arguments Type Intent Optional Attributes Name integer, intent(in), Dimension( 1:3 ) :: s Where to start integer, intent(in), Dimension( 1:3 ) :: lg Lower bound of grid array integer, intent(in), Dimension( 1:3 ) :: ll Lower bound of laplacian array integer, intent(in), Dimension( 1:3 ) :: nb Cache blocking factors integer, intent(in), Dimension( 1:3 ) :: f Where to finish integer, intent(in) :: order Order of the FD approximation real(kind=wp), intent(in), Dimension( -order: ) :: w1 FD Weights for first derivs real(kind=wp), intent(in), Dimension( -order: ) :: w2 FD Weights for second derivs real(kind=wp), intent(in), Dimension( 1:6     ) :: deriv_weights See below real(kind=wp), intent(in), Dimension( lg( 1 ):, lg( 2 ):, lg( 3 ): ) :: grid The source real(kind=wp), intent(inout), Dimension( ll( 1 ):, ll( 2 ):, ll( 3 ): ) :: laplacian The result Called by proc~~apply_block~~CalledByGraph proc~apply_block apply_block proc~apply apply proc~apply->proc~apply_block Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code apply_block Source Code Pure Subroutine apply_block ( s , lg , ll , nb , f , order , w1 , w2 , deriv_weights , grid , laplacian ) !!----------------------------------------------------------- !! Apply the FD laplacian operator to part of the grid. An effort has been made !! to make sure the required data is in cache !! !! Written by I.J. Bush !!----------------------------------------------------------- Integer , Dimension ( 1 : 3 ) , Intent ( In ) :: s !! Where to start Integer , Dimension ( 1 : 3 ) , Intent ( In ) :: lg !! Lower bound of grid array Integer , Dimension ( 1 : 3 ) , Intent ( In ) :: ll !! Lower bound of laplacian array Integer , Dimension ( 1 : 3 ) , Intent ( In ) :: nb !! Cache blocking factors Integer , Dimension ( 1 : 3 ) , Intent ( In ) :: f !! Where to finish Integer , Intent ( In ) :: order !! Order of the FD approximation Real ( wp ), Dimension ( - order : ), Intent ( In ) :: w1 !! FD Weights for first derivs Real ( wp ), Dimension ( - order : ), Intent ( In ) :: w2 !! FD Weights for second derivs Real ( wp ), Dimension ( 1 : 6 ), Intent ( In ) :: deriv_weights !! See below Real ( wp ), Dimension ( lg ( 1 ):, lg ( 2 ):, lg ( 3 ): ), Intent ( In ) :: grid !! The source Real ( wp ), Dimension ( ll ( 1 ):, ll ( 2 ):, ll ( 3 ): ), Intent ( InOut ) :: laplacian !! The result ! Deriv_weights: As we do NOT assume the grid is orthogonal our FD laplacian is of the form ! d_xx * del_xx + d_xy * del_xy + d_xz * del_xz + d_yy * del_yy + d_yz * del_yz + d_zz * del_zz ! as we must finite difference along the directions of the grid. deriv_weights are the d_xx, d_xy ! etc. coefficients in this expression Real ( wp ), Parameter :: orthog_tol = 1.0e-14_wp Real ( wp ) :: st1 , st2 , st3 Real ( wp ) :: fac1 , fac2 , fac3 Real ( wp ) :: st12 , st13 , st23 Real ( wp ) :: fac12 , fac13 , fac23 Integer :: i3 , i2 , i1 Integer :: it , it1 , it2 , it3 ! Order the loops for the various terms so that the inner loop is stride 1 ! First do the xx, yy, zz terms. Assume the weights of these are always non-zero Do i3 = s ( 3 ), Min ( s ( 3 ) + nb ( 3 ) - 1 , f ( 3 ) ) Do i2 = s ( 2 ), Min ( s ( 2 ) + nb ( 2 ) - 1 , f ( 2 ) ) Do i1 = s ( 1 ), Min ( s ( 1 ) + nb ( 1 ) - 1 , f ( 1 ) ) ! FD x&#94;2, y&#94;2, z&#94;2 at grid point laplacian ( i1 , i2 , i3 ) = w2 ( 0 ) * deriv_weights ( 1 ) * grid ( i1 , i2 , i3 ) laplacian ( i1 , i2 , i3 ) = laplacian ( i1 , i2 , i3 ) + w2 ( 0 ) * deriv_weights ( 4 ) * grid ( i1 , i2 , i3 ) laplacian ( i1 , i2 , i3 ) = laplacian ( i1 , i2 , i3 ) + w2 ( 0 ) * deriv_weights ( 6 ) * grid ( i1 , i2 , i3 ) ! FD x&#94;2 Do it = 1 , order fac1 = w2 ( it ) * deriv_weights ( 1 ) st1 = ( grid ( i1 + it , i2 , i3 ) + grid ( i1 - it , i2 , i3 ) ) laplacian ( i1 , i2 , i3 ) = laplacian ( i1 , i2 , i3 ) + fac1 * st1 End Do End Do End Do End Do ! FD y&#94;2, z&#94;2 Do i3 = s ( 3 ), Min ( s ( 3 ) + nb ( 3 ) - 1 , f ( 3 ) ) Do i2 = s ( 2 ), Min ( s ( 2 ) + nb ( 2 ) - 1 , f ( 2 ) ) Do it = 1 , order Do i1 = s ( 1 ), Min ( s ( 1 ) + nb ( 1 ) - 1 , f ( 1 ) ) fac2 = w2 ( it ) * deriv_weights ( 4 ) st2 = ( grid ( i1 , i2 + it , i3 ) + grid ( i1 , i2 - it , i3 ) ) laplacian ( i1 , i2 , i3 ) = laplacian ( i1 , i2 , i3 ) + fac2 * st2 fac3 = w2 ( it ) * deriv_weights ( 6 ) st3 = ( grid ( i1 , i2 , i3 + it ) + grid ( i1 , i2 , i3 - it ) ) laplacian ( i1 , i2 , i3 ) = laplacian ( i1 , i2 , i3 ) + fac3 * st3 End Do End Do End Do End Do ! xy If ( Abs ( deriv_weights ( 2 ) ) > orthog_tol ) Then Do i3 = s ( 3 ), Min ( s ( 3 ) + nb ( 3 ) - 1 , f ( 3 ) ) Do i2 = s ( 2 ), Min ( s ( 2 ) + nb ( 2 ) - 1 , f ( 2 ) ) Do it2 = 1 , order Do i1 = s ( 1 ), Min ( s ( 1 ) + nb ( 1 ) - 1 , f ( 1 ) ) ! first derivs have zero weight at the grid point for central differences Do it1 = 1 , order fac12 = w1 ( it1 ) * w1 ( it2 ) * deriv_weights ( 2 ) st12 = grid ( i1 + it1 , i2 + it2 , i3 ) - grid ( i1 - it1 , i2 + it2 , i3 ) - & ( grid ( i1 + it1 , i2 - it2 , i3 ) - grid ( i1 - it1 , i2 - it2 , i3 ) ) laplacian ( i1 , i2 , i3 ) = laplacian ( i1 , i2 , i3 ) + fac12 * st12 End Do End Do End Do End Do End Do End If ! xz If ( Abs ( deriv_weights ( 3 ) ) > orthog_tol ) Then Do i3 = s ( 3 ), Min ( s ( 3 ) + nb ( 3 ) - 1 , f ( 3 ) ) Do it3 = 1 , order Do i2 = s ( 2 ), Min ( s ( 2 ) + nb ( 2 ) - 1 , f ( 2 ) ) Do i1 = s ( 1 ), Min ( s ( 1 ) + nb ( 1 ) - 1 , f ( 1 ) ) ! first derivs have zero weight at the grid point for central differences Do it1 = 1 , order fac13 = w1 ( it1 ) * w1 ( it3 ) * deriv_weights ( 3 ) st13 = grid ( i1 + it1 , i2 , i3 + it3 ) - grid ( i1 - it1 , i2 , i3 + it3 ) - & ( grid ( i1 + it1 , i2 , i3 - it3 ) - grid ( i1 - it1 , i2 , i3 - it3 ) ) laplacian ( i1 , i2 , i3 ) = laplacian ( i1 , i2 , i3 ) + fac13 * st13 End Do End Do End Do End Do End Do End If ! yz If ( Abs ( deriv_weights ( 5 ) ) > orthog_tol ) Then Do i3 = s ( 3 ), Min ( s ( 3 ) + nb ( 3 ) - 1 , f ( 3 ) ) Do it3 = 1 , order Do i2 = s ( 2 ), Min ( s ( 2 ) + nb ( 2 ) - 1 , f ( 2 ) ) ! first derivs have zero weight at the grid point for central differences Do it2 = 1 , order Do i1 = s ( 1 ), Min ( s ( 1 ) + nb ( 1 ) - 1 , f ( 1 ) ) fac23 = w1 ( it2 ) * w1 ( it3 ) * deriv_weights ( 5 ) st23 = grid ( i1 , i2 + it2 , i3 + it3 ) - grid ( i1 , i2 - it2 , i3 + it3 ) - & ( grid ( i1 , i2 + it2 , i3 - it3 ) - grid ( i1 , i2 - it2 , i3 - it3 ) ) laplacian ( i1 , i2 , i3 ) = laplacian ( i1 , i2 , i3 ) + fac23 * st23 End Do End Do End Do End Do End Do End If End Subroutine apply_block","tags":"","loc":"proc/apply_block.html","title":"apply_block – Fortran Program"},{"text":"private pure function get_order(FD) result(order) Return stencil order Written by I.J. Bush Arguments Type Intent Optional Attributes Name class( FD_template ), intent(in) :: FD Return Value integer Contents Source Code get_order Source Code Pure Function get_order ( FD ) Result ( order ) !!----------------------------------------------------------- !! Return stencil order !! !! Written by I.J. Bush !!----------------------------------------------------------- Integer :: order Class ( FD_template ), Intent ( In ) :: FD order = FD % order End Function get_order","tags":"","loc":"proc/get_order.html","title":"get_order – Fortran Program"},{"text":"private pure function get_max_deriv(FD) result(max_deriv) Return maximum possible derivative order Written by I.J. Bush Arguments Type Intent Optional Attributes Name class( FD_template ), intent(in) :: FD Return Value integer Contents Source Code get_max_deriv Source Code Pure Function get_max_deriv ( FD ) Result ( max_deriv ) !!----------------------------------------------------------- !! Return maximum possible derivative order !! !! Written by I.J. Bush !!----------------------------------------------------------- Integer :: max_deriv Class ( FD_template ), Intent ( In ) :: FD max_deriv = FD % max_deriv End Function get_max_deriv","tags":"","loc":"proc/get_max_deriv.html","title":"get_max_deriv – Fortran Program"},{"text":"private pure function get_weight(FD, deriv) result(weight) Return FD weights for given derivative order Written by I.J. Bush Arguments Type Intent Optional Attributes Name class( FD_template ), intent(in) :: FD integer, intent(in) :: deriv Return Value real(kind=wp),\n  Allocatable,Dimension( : ) Contents Source Code get_weight Source Code Pure Function get_weight ( FD , deriv ) Result ( weight ) !!----------------------------------------------------------- !! Return FD weights for given derivative order !! !! Written by I.J. Bush !!----------------------------------------------------------- Real ( wp ), Allocatable , Dimension ( : ) :: weight Class ( FD_template ), Intent ( In ) :: FD Integer , Intent ( In ) :: deriv Allocate ( weight ( - FD % order : FD % order ) ) weight = FD % weights ( :, deriv ) End Function get_weight","tags":"","loc":"proc/get_weight.html","title":"get_weight – Fortran Program"},{"text":"private subroutine FD_init(FD, max_deriv, order, vecs) Initialise finite difference object for arbitrary grids Written by I.J. Bush Arguments Type Intent Optional Attributes Name class( FD_template ), intent(out) :: FD integer, intent(in) :: max_deriv integer, intent(in) :: order real(kind=wp), intent(in), Dimension( :, : ) :: vecs Contents Source Code FD_init Source Code Subroutine FD_init ( FD , max_deriv , order , vecs ) !!----------------------------------------------------------- !! Initialise finite difference object for arbitrary grids !! !! Written by I.J. Bush !!----------------------------------------------------------- Class ( FD_template ) , Intent ( Out ) :: FD Integer , Intent ( In ) :: max_deriv Integer , Intent ( In ) :: order Real ( wp ), Dimension ( :, : ), Intent ( In ) :: vecs Call FD % set_order ( max_deriv , order ) Call FD % set_dir_vecs ( vecs ) End Subroutine FD_init","tags":"","loc":"proc/fd_init.html","title":"FD_init – Fortran Program"},{"text":"private subroutine set_order(FD, max_deriv, order) Set derivative and stencil and calculate respective weights Written by I.J. Bush Arguments Type Intent Optional Attributes Name class( FD_template ), intent(inout) :: FD integer, intent(in) :: max_deriv integer, intent(in) :: order Contents Source Code set_order Source Code Subroutine set_order ( FD , max_deriv , order ) !!----------------------------------------------------------- !! Set derivative and stencil and calculate respective weights !! !! Written by I.J. Bush !!----------------------------------------------------------- Class ( FD_template ), Intent ( InOut ) :: FD Integer , Intent ( In ) :: max_deriv Integer , Intent ( In ) :: order Integer :: i FD % max_deriv = max_deriv FD % order = order Call weights ( 0.0_wp , [ ( Real ( i , wp ), i = - FD % order , FD % order ) ], & FD % max_deriv , FD % weights ) End Subroutine set_order","tags":"","loc":"proc/set_order.html","title":"set_order – Fortran Program"},{"text":"private subroutine weights(centre, sample_points, deriv, coeffs) Input Arguments\n centre                      -- location where approximations are to be accurate,\n sample_points(0:n_samples)  -- grid point locations\n deriv                       -- highest derivative for which weights are sought, Output Arguments\n coeffs(0:n_samples,0:deriv) -- weights at sample_points for derivatives order deriv Taken from https://pdfs.semanticscholar.org/8bf5/912bde884f6bd4cfb4991ba3d077cace94c0.pdf\n By Bengt Fornberg Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: centre real(kind=wp), intent(in), Dimension( 0: ) :: sample_points integer, intent(in) :: deriv real(kind=wp), intent(out), Dimension( :, : ), Allocatable :: coeffs Contents Source Code weights Source Code Subroutine weights ( centre , sample_points , deriv , coeffs ) !!----------------------------------------------------------- !! Input Arguments !! centre                      -- location where approximations are to be accurate, !! sample_points(0:n_samples)  -- grid point locations !! deriv                       -- highest derivative for which weights are sought, !! !! Output Arguments !! coeffs(0:n_samples,0:deriv) -- weights at sample_points for derivatives order deriv !! !! Taken from https://pdfs.semanticscholar.org/8bf5/912bde884f6bd4cfb4991ba3d077cace94c0.pdf !! By Bengt Fornberg !!----------------------------------------------------------- Implicit None Real ( wp ), Intent ( In ) :: centre Real ( wp ), Dimension ( 0 : ), Intent ( In ) :: sample_points Integer , Intent ( In ) :: deriv Real ( wp ), Dimension ( :, : ), Allocatable , Intent ( Out ) :: coeffs Integer :: n Real ( wp ) :: c1 , c2 , c3 , c4 , c5 Integer :: mn Integer :: i , j , k Integer :: ierr n = size ( sample_points ) - 1 Allocate ( coeffs ( 0 : n , 0 : deriv ), stat = ierr ) If ( ierr /= 0 ) Stop \"Error in allocation of coeffs in weights\" c1 = 1.0_wp c4 = sample_points ( 0 ) - centre coeffs = 0.0_wp coeffs ( 0 , 0 ) = 1.0_wp Do i = 1 , n mn = Min ( i , deriv ) c2 = 1.0_wp c5 = c4 c4 = sample_points ( i ) - centre Do j = 0 , i - 1 c3 = sample_points ( i ) - sample_points ( j ) c2 = c2 * c3 If ( j . Eq . i - 1 ) Then ! If final iteration Do k = mn , 1 , - 1 coeffs ( i , k ) = c1 * ( k * coeffs ( i - 1 , k - 1 ) - c5 * coeffs ( i - 1 , k )) / c2 End Do coeffs ( i , 0 ) = - c1 * c5 * coeffs ( i - 1 , 0 ) / c2 Endif Do k = mn , 1 , - 1 coeffs ( j , k ) = ( c4 * coeffs ( j , k ) - k * coeffs ( j , k - 1 )) / c3 End Do coeffs ( j , 0 ) = c4 * coeffs ( j , 0 ) / c3 End Do c1 = c2 End Do End Subroutine weights","tags":"","loc":"proc/weights.html","title":"weights – Fortran Program"},{"text":"Module containing type and functions pertaining to\n calculating finite-difference grid contributions\n for non-orthonormal grids. Written by I.J. Bush Uses numbers_module module~~grid_vectors_module~~UsesGraph module~grid_vectors_module grid_vectors_module module~numbers_module numbers_module module~grid_vectors_module->module~numbers_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~grid_vectors_module~~UsedByGraph module~grid_vectors_module grid_vectors_module module~fd_template_module FD_template_module module~fd_template_module->module~grid_vectors_module module~fd_laplacian_3d_module FD_Laplacian_3d_module module~fd_laplacian_3d_module->module~fd_template_module program~testit testit program~testit->module~fd_laplacian_3d_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types grid_vectors Functions get_dir_vec get_inv_vec get_volume Subroutines set_dir_vecs givens_invert Derived Types type, public :: grid_vectors Type to handle grids of arbitrary size and orientation\n and the calculation of relevant parameters thereof Read more… Components Type Visibility Attributes Name Initial real(kind=wp), private, Dimension( :, : ), Allocatable :: dir_vecs real(kind=wp), private :: volume real(kind=wp), private, Dimension( :, : ), Allocatable :: inv_vecs Type-Bound Procedures procedure, public :: set_dir_vecs procedure, public :: get_dir_vec procedure, public :: get_volume procedure, public :: get_inv_vec Functions private pure function get_dir_vec (g, which) result(v) Get the direction of a given (which) vector from\n the direction vecs Read more… Arguments Type Intent Optional Attributes Name class( grid_vectors ), intent(in) :: g integer, intent(in) :: which Return Value real(kind=wp),\n  Dimension( : ), Allocatable private pure function get_inv_vec (g, which) result(v) Get the inverse direction of a given (which) vector from\n the direction vecs Read more… Arguments Type Intent Optional Attributes Name class( grid_vectors ), intent(in) :: g integer, intent(in) :: which Return Value real(kind=wp),\n  Dimension( : ), Allocatable private pure function get_volume (g) result(V) Get the volume element from the vectors Read more… Arguments Type Intent Optional Attributes Name class( grid_vectors ), intent(in) :: g Return Value real(kind=wp) Subroutines private subroutine set_dir_vecs (g, vecs) Set grid vectors as an NxN array (vecs) and thereby\n calculate the various properties for use with the\n rest of the solvers Read more… Arguments Type Intent Optional Attributes Name class( grid_vectors ), intent(inout) :: g real(kind=wp), intent(in), Dimension( :, : ) :: vecs private subroutine givens_invert (A, B, det) Invert the matrix A, returning the inverse in B\n and the determinant of A in det Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), Dimension( 1:, 1: ) :: A real(kind=wp), intent(out), Dimension( 1:, 1: ) :: B real(kind=wp), intent(out), optional :: det","tags":"","loc":"module/grid_vectors_module.html","title":"grid_vectors_module – Fortran Program"},{"text":"Uses numbers_module FD_template_module module~~fd_laplacian_3d_module~~UsesGraph module~fd_laplacian_3d_module FD_Laplacian_3d_module module~fd_template_module FD_template_module module~fd_laplacian_3d_module->module~fd_template_module module~numbers_module numbers_module module~fd_laplacian_3d_module->module~numbers_module module~grid_vectors_module grid_vectors_module module~fd_template_module->module~grid_vectors_module module~grid_vectors_module->module~numbers_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~fd_laplacian_3d_module~~UsedByGraph module~fd_laplacian_3d_module FD_Laplacian_3d_module program~testit testit program~testit->module~fd_laplacian_3d_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables n_cache XX XY XZ YY YZ ZZ Derived Types FD_Laplacian_3d Functions usage Subroutines init reset_vecs apply apply_block Variables Type Visibility Attributes Name Initial integer, public, parameter :: n_cache = (2**18)/(8) integer, public, parameter :: XX = 1 integer, public, parameter :: XY = 2 integer, public, parameter :: XZ = 3 integer, public, parameter :: YY = 4 integer, public, parameter :: YZ = 5 integer, public, parameter :: ZZ = 6 Derived Types type, public, Extends( FD_template ) :: FD_Laplacian_3d Components Type Visibility Attributes Name Initial integer, private, Dimension( 1:3 ) :: nc_block real(kind=wp), private, Dimension( 1:6 ) :: deriv_weights Type-Bound Procedures procedure, public :: init procedure, public :: reset_vecs procedure, public :: apply Functions private pure function usage (nc_block, accuracy) result(reals) Estimate memory usage of current block size Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), Dimension( 1:3 ) :: nc_block integer, intent(in) :: accuracy Return Value integer Subroutines private subroutine init (FD, order, vecs) Initialise Laplacian differentiator and calculate\n optimal blocking in cache. Read more… Arguments Type Intent Optional Attributes Name class( FD_Laplacian_3d ), intent(out) :: FD integer, intent(in) :: order real(kind=wp), intent(in), Dimension( :, : ) :: vecs private subroutine reset_vecs (FD, vecs) Calculate weights due to grid offset for non-orthogonal grids Read more… Arguments Type Intent Optional Attributes Name class( FD_Laplacian_3d ), intent(inout) :: FD real(kind=wp), intent(in), Dimension( :, : ) :: vecs private subroutine apply (FD, grid_lb, lap_lb, start, final, grid, laplacian) Calculate the resulting derivative by applying sequentially\n to the precalculated cache-blocks Read more… Arguments Type Intent Optional Attributes Name class( FD_Laplacian_3d ), intent(in) :: FD integer, intent(in), Dimension(3) :: grid_lb lower bounds grid integer, intent(in), Dimension(3) :: lap_lb lower bounds laplacian integer, intent(in), Dimension(3) :: start start point for calculation integer, intent(in), Dimension(3) :: final final point for calculation real(kind=wp), intent(in), Dimension( grid_lb(1):, grid_lb(2):, grid_lb(3): ) :: grid Thing to be differentiated real(kind=wp), intent(out), Dimension( lap_lb(1):, lap_lb(2):, lap_lb(3): ) :: laplacian private subroutine apply_block (s, lg, ll, nb, f, order, w1, w2, deriv_weights, grid, laplacian) Apply the FD laplacian operator to part of the grid. An effort has been made\n to make sure the required data is in cache Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), Dimension( 1:3 ) :: s Where to start integer, intent(in), Dimension( 1:3 ) :: lg Lower bound of grid array integer, intent(in), Dimension( 1:3 ) :: ll Lower bound of laplacian array integer, intent(in), Dimension( 1:3 ) :: nb Cache blocking factors integer, intent(in), Dimension( 1:3 ) :: f Where to finish integer, intent(in) :: order Order of the FD approximation real(kind=wp), intent(in), Dimension( -order: ) :: w1 FD Weights for first derivs real(kind=wp), intent(in), Dimension( -order: ) :: w2 FD Weights for second derivs real(kind=wp), intent(in), Dimension( 1:6     ) :: deriv_weights See below real(kind=wp), intent(in), Dimension( lg( 1 ):, lg( 2 ):, lg( 3 ): ) :: grid The source real(kind=wp), intent(inout), Dimension( ll( 1 ):, ll( 2 ):, ll( 3 ): ) :: laplacian The result","tags":"","loc":"module/fd_laplacian_3d_module.html","title":"FD_Laplacian_3d_module – Fortran Program"},{"text":"Used by module~~numbers_module~~UsedByGraph module~numbers_module numbers_module module~grid_vectors_module grid_vectors_module module~grid_vectors_module->module~numbers_module module~fd_laplacian_3d_module FD_Laplacian_3d_module module~fd_laplacian_3d_module->module~numbers_module module~fd_template_module FD_template_module module~fd_laplacian_3d_module->module~fd_template_module program~testit testit program~testit->module~numbers_module program~testit->module~fd_laplacian_3d_module module~fd_template_module->module~grid_vectors_module var panmodulenumbers_moduleUsedByGraph = svgPanZoom('#modulenumbers_moduleUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables wp Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = Selected_real_kind(12, 70)","tags":"","loc":"module/numbers_module.html","title":"numbers_module – Fortran Program"},{"text":"Module containing type to construct finite difference weights\n for arbitrary order derivatives, stencils and arbitrary grids Written by I.J. Bush Uses grid_vectors_module module~~fd_template_module~~UsesGraph module~fd_template_module FD_template_module module~grid_vectors_module grid_vectors_module module~fd_template_module->module~grid_vectors_module module~numbers_module numbers_module module~grid_vectors_module->module~numbers_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~fd_template_module~~UsedByGraph module~fd_template_module FD_template_module module~fd_laplacian_3d_module FD_Laplacian_3d_module module~fd_laplacian_3d_module->module~fd_template_module program~testit testit program~testit->module~fd_laplacian_3d_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables wp Derived Types FD_template Functions get_order get_max_deriv get_weight Subroutines FD_init set_order weights Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = Selected_real_kind(15, 300) Derived Types type, public, Abstract, Extends( grid_vectors ) :: FD_template Low-level type for handling weights for arbitray stencils\n and derivatives, contains grid_vector information through\n the extension of the grid_vectors type. Read more… Components Type Visibility Attributes Name Initial integer, private :: max_deriv integer, private :: order real(kind=wp), private, Dimension( :, : ), Allocatable :: weights Type-Bound Procedures procedure, public :: FD_init procedure, public :: set_order procedure, public :: get_order procedure, public :: get_max_deriv procedure, public :: get_weight Functions private pure function get_order (FD) result(order) Return stencil order Read more… Arguments Type Intent Optional Attributes Name class( FD_template ), intent(in) :: FD Return Value integer private pure function get_max_deriv (FD) result(max_deriv) Return maximum possible derivative order Read more… Arguments Type Intent Optional Attributes Name class( FD_template ), intent(in) :: FD Return Value integer private pure function get_weight (FD, deriv) result(weight) Return FD weights for given derivative order Read more… Arguments Type Intent Optional Attributes Name class( FD_template ), intent(in) :: FD integer, intent(in) :: deriv Return Value real(kind=wp),\n  Allocatable, Dimension( : ) Subroutines private subroutine FD_init (FD, max_deriv, order, vecs) Initialise finite difference object for arbitrary grids Read more… Arguments Type Intent Optional Attributes Name class( FD_template ), intent(out) :: FD integer, intent(in) :: max_deriv integer, intent(in) :: order real(kind=wp), intent(in), Dimension( :, : ) :: vecs private subroutine set_order (FD, max_deriv, order) Set derivative and stencil and calculate respective weights Read more… Arguments Type Intent Optional Attributes Name class( FD_template ), intent(inout) :: FD integer, intent(in) :: max_deriv integer, intent(in) :: order private subroutine weights (centre, sample_points, deriv, coeffs) Input Arguments\n centre                      -- location where approximations are to be accurate,\n sample_points(0:n_samples)  -- grid point locations\n deriv                       -- highest derivative for which weights are sought, Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: centre real(kind=wp), intent(in), Dimension( 0: ) :: sample_points integer, intent(in) :: deriv real(kind=wp), intent(out), Dimension( :, : ), Allocatable :: coeffs","tags":"","loc":"module/fd_template_module.html","title":"FD_template_module – Fortran Program"},{"text":"Uses numbers_module FD_Laplacian_3d_module program~~testit~~UsesGraph program~testit testit module~numbers_module numbers_module program~testit->module~numbers_module module~fd_laplacian_3d_module FD_Laplacian_3d_module program~testit->module~fd_laplacian_3d_module module~fd_laplacian_3d_module->module~numbers_module module~fd_template_module FD_template_module module~fd_laplacian_3d_module->module~fd_template_module module~grid_vectors_module grid_vectors_module module~fd_template_module->module~grid_vectors_module module~grid_vectors_module->module~numbers_module var panprogramtestitUsesGraph = svgPanZoom('#programtestitUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Program to test the execution of the finite difference\n library by calculating the charge from a screened\n Gaussian according to \\rho _i&#94;s(\\mathbf r)=-q_i\\left(\\frac{\\alpha }{\\sqrt{\\pi }}\\right)&#94;3e&#94;{-\\alpha&#94;2 |\\mathbf r-\\mathbf r_i|&#94;2} Written by I.J. Bush Contents Variables FD grid laplacian fd_laplacian grid_vecs r ri alpha alpha_sq x y z norm arg gauss gauss_x2 gauss_y2 gauss_z2 grid_size grid_with_halo order i3 i2 i1 Source Code testit Variables Type Attributes Name Initial type( FD_Laplacian_3d ) :: FD real(kind=wp), Dimension( :, :, : ), Allocatable :: grid real(kind=wp), Dimension( :, :, : ), Allocatable :: laplacian real(kind=wp), Dimension( :, :, : ), Allocatable :: fd_laplacian real(kind=wp), Dimension( 1:3, 1:3 ) :: grid_vecs real(kind=wp), Dimension( 1:3 ) :: r real(kind=wp), Dimension( 1:3 ) :: ri real(kind=wp) :: alpha real(kind=wp) :: alpha_sq real(kind=wp) :: x real(kind=wp) :: y real(kind=wp) :: z real(kind=wp) :: norm real(kind=wp) :: arg real(kind=wp) :: gauss real(kind=wp) :: gauss_x2 real(kind=wp) :: gauss_y2 real(kind=wp) :: gauss_z2 integer, Dimension( 1:3 ) :: grid_size integer, Dimension( 1:3 ) :: grid_with_halo integer :: order integer :: i3 integer :: i2 integer :: i1 Source Code Program testit !!---------------------------------------------------- !! Program to test the execution of the finite difference !! library by calculating the charge from a screened !! Gaussian according to !!  \\rho _i&#94;s(\\mathbf r)=-q_i\\left(\\frac{\\alpha }{\\sqrt{\\pi }}\\right)&#94;3e&#94;{-\\alpha&#94;2 |\\mathbf r-\\mathbf r_i|&#94;2}  !! !! Written by I.J. Bush !!---------------------------------------------------- Use numbers_module , Only : wp Use FD_Laplacian_3d_module , Only : FD_Laplacian_3D Implicit None Type ( FD_Laplacian_3d ) :: FD Real ( wp ), Dimension ( :, :, : ), Allocatable :: grid Real ( wp ), Dimension ( :, :, : ), Allocatable :: laplacian Real ( wp ), Dimension ( :, :, : ), Allocatable :: fd_laplacian Real ( wp ), Dimension ( 1 : 3 , 1 : 3 ) :: grid_vecs Real ( wp ), Dimension ( 1 : 3 ) :: r , ri Real ( wp ) :: alpha , alpha_sq Real ( wp ) :: x , y , z Real ( wp ) :: norm Real ( wp ) :: arg Real ( wp ) :: gauss , gauss_x2 , gauss_y2 , gauss_z2 Integer , Dimension ( 1 : 3 ) :: grid_size , grid_with_halo Integer :: order Integer :: i3 , i2 , i1 Write ( * , * ) 'Grid vecs?' Read ( * , * ) grid_vecs Write ( * , * ) 'ri ?' Read ( * , * ) ri Write ( * , * ) 'alpha ?' Read ( * , * ) alpha alpha_sq = alpha * alpha Write ( * , * ) 'order ?' Read ( * , * ) order Write ( * , * ) 'grid_size ?' Read ( * , * ) grid_size grid_with_halo = grid_size + order / 2 Allocate ( grid ( & & - grid_with_halo ( 1 ): grid_with_halo ( 1 ), & & - grid_with_halo ( 2 ): grid_with_halo ( 2 ), & & - grid_with_halo ( 3 ): grid_with_halo ( 3 ) ) ) Allocate ( laplacian ( & & - grid_with_halo ( 1 ): grid_with_halo ( 1 ), & & - grid_with_halo ( 2 ): grid_with_halo ( 2 ), & & - grid_with_halo ( 3 ): grid_with_halo ( 3 ) ) ) Allocate ( fd_laplacian ( & & - grid_size ( 1 ): grid_size ( 1 ), & & - grid_size ( 2 ): grid_size ( 2 ), & & - grid_size ( 3 ): grid_size ( 3 ) ) ) norm = ( alpha / Sqrt ( 3.1415926535897932384626433832795_wp ) ) ** 3 Do i3 = - grid_with_halo ( 3 ), grid_with_halo ( 3 ) Do i2 = - grid_with_halo ( 2 ), grid_with_halo ( 2 ) Do i1 = - grid_with_halo ( 1 ), grid_with_halo ( 1 ) r = i1 * grid_vecs ( :, 1 ) + i2 * grid_vecs ( :, 2 ) + i3 * grid_vecs ( :, 3 ) - ri arg = alpha_sq * Dot_Product ( r , r ) gauss = norm * Exp ( - arg ) grid ( i1 , i2 , i3 ) = gauss x = r ( 1 ) y = r ( 2 ) z = r ( 3 ) gauss_x2 = gauss * ( - 2.0_wp * alpha_sq + 4.0 * alpha_sq * alpha_sq * x * x ) gauss_y2 = gauss * ( - 2.0_wp * alpha_sq + 4.0 * alpha_sq * alpha_sq * y * y ) gauss_z2 = gauss * ( - 2.0_wp * alpha_sq + 4.0 * alpha_sq * alpha_sq * z * z ) laplacian ( i1 , i2 , i3 ) = gauss_x2 + gauss_y2 + gauss_z2 End Do End Do End Do Call FD % init ( order , grid_vecs ) Call FD % apply ( - grid_with_halo , - grid_size , & - grid_size , grid_size , & grid , fd_laplacian ) Write ( * , * ) Maxval ( Abs ( fd_laplacian - & laplacian ( & & - grid_size ( 1 ): grid_size ( 1 ), & & - grid_size ( 2 ): grid_size ( 2 ), & & - grid_size ( 3 ): grid_size ( 3 ) ) ) ) Write ( * , * ) Maxval ( Abs ( laplacian ( & & - grid_size ( 1 ): grid_size ( 1 ), & & - grid_size ( 2 ): grid_size ( 2 ), & & - grid_size ( 3 ): grid_size ( 3 ) ) ) ) End Program testit","tags":"","loc":"program/testit.html","title":"testit – Fortran Program"}]}